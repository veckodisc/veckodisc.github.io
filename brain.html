<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>The Second Brain</title>
		<link rel="stylesheet" href="css/brain.css">
	</head>
	<body>

		<img class="axis_info" id="axis_info" src="images/cube_axis.png" alt="Axis explanation">
		<img class="info_button" id="info_button" src="images/info.png" alt="Show info">
		
		<h1 id='title'></h1>
		<div class='info'>
			<h3 id='section_title'></h3>
			<p id='section_intro'></p>
		</div>
		
		<script type="module">
			
		    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0/build/three.module.js';
		    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
		    import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
		    import { FontLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/FontLoader.js';
		    import { TextGeometry } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/TextGeometry.js';
		    
		    const scene = new THREE.Scene();
		    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		    const renderer = new THREE.WebGLRenderer( { antialias: true } );
		    const geometry = new THREE.BoxGeometry();
		    
		    let cubes = JSON.parse(localStorage.getItem("cubes"));
		    let cube = null;
		    for (let i = 0; i < cubes.length; i++) {
		    	if(cubes[i].id == localStorage.getItem("current_cube")) {
		    		cube = cubes[i];
		    	}
		    }
		    document.getElementById("title").innerHTML = cube.title;
		    
		    const controls = new OrbitControls( camera, renderer.domElement );
		    const gltfLoader = new GLTFLoader();
		    
		    const color = 0xFFFFFF;
		    const intensity = 1;
		    const light = new THREE.DirectionalLight(color, intensity);
		    light.position.set(-1, 2, 4);
		    scene.add(light);	
		    scene.add( new THREE.AmbientLight( 0xffffff, 0.4 ) );
			
		    let objects = [];
		    let secs = cube.sections;
		    for (let pos = 0; pos < secs.length; pos++) {
		    	console.log(secs[pos]);
		    	const material = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
		    	const cube = new THREE.Mesh( geometry, material );
		    	let x = 1;
		    	let y = 1;
		    	let z = 1;
		    	if (pos % 3 == 0) {
					x = -1;
				} else if (pos % 3 == 1) {
					x = 0;
				}
				if (Math.floor(pos / 3) % 3 == 0) {
					y = -1;
				} else if (Math.floor(pos / 3) % 3 == 1) {
					y = 0;
				}
				if (Math.floor(pos / 9) == 0) {
					z = -1;
				} else if (Math.floor(pos / 9) == 1) {
					z = 0;
				}
				const gap = 1.25;
				cube.position.set( x * gap, y * gap, z * gap );
				cube.material.transparent = true;
		    	cube.material.opacity = 0.6; 
		    	cube.userData = {
                	id: secs[pos].id,
                	title: secs[pos].title,
                	intro: secs[pos].intro
            	};
            	scene.add( cube );
            	objects.push(cube);
		    }
		    
		    camera.position.set(4.5,3.8,4.5);
		    camera.lookAt(new THREE.Vector3(0,0,0)); 
		    let raycaster = new THREE.Raycaster();
		    let mouse = new THREE.Vector2();
		    renderer.setPixelRatio(window.devicePixelRatio);
		    
		    renderer.setSize( window.innerWidth, window.innerHeight );
		    document.body.appendChild( renderer.domElement );
		    
		    document.addEventListener( 'mousemove', onDocumentMouseMove );
			window.addEventListener( 'resize', onWindowResize );
		    
		    document.addEventListener( 'dblclick', onDocumentDoubleClicked, false );
		    document.addEventListener("mousedown", onMouseDown);
		    document.getElementById("info_button").addEventListener("mouseup", toggleInfo);
		    
		    
		    function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}
			
			function onDocumentDoubleClicked(event) {
    			event.preventDefault();
    			raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
    			if (intersects.length > 0) {
        			localStorage.setItem('current_section', intersects[0].object.userData.id);
        			window.location.href = "section.html";
    			}
			}
			
			function onMouseDown(event) {
    			event.preventDefault();
    			raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
    			if (intersects.length > 0) {
        			document.getElementById("section_title").innerHTML = intersects[0].object.userData.title;
        			document.getElementById("section_intro").innerHTML = intersects[0].object.userData.intro;
    			}
			}
			
			function toggleInfo(event) {
    			event.preventDefault();
    			let axis_info = document.getElementById("axis_info");
				if (axis_info.style.display === "none" || axis_info.style.display === "") {
					axis_info.style.display = "block";
					document.getElementById("section_title").innerHTML = "Klicka på ett område för mer information";
    				document.getElementById("section_intro").innerHTML = "Dubbelklicka på området för att öppna det";
				} else {
					axis_info.style.display = "none";
					document.getElementById("section_title").innerHTML = '';
    				document.getElementById("section_intro").innerHTML = '';
				}
			}

		    function animate() {
		        requestAnimationFrame( animate );
		        renderer.render( scene, camera );
		    }
		    animate();

		</script>
	</body>
</html>
