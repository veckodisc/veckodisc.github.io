<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>The Second Brain</title>
		<link rel="stylesheet" href="css/brain.css">
		<script src="js/utils.js"></script>
	</head>
	<body>
		<img class="axis_info" id="axis_info" src="images/cube_axis.png" alt="Axis explanation">
		<img class="info_button" id="info_button" src="images/info.png" alt="Show info">
		
		<h1 id='title'></h1>
		<div class='info'>
			<h3 id='section_title'></h3>
			<p id='section_intro'></p>
		</div>
		
		<script type="module">
			
		    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0/build/three.module.js';
		    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
		    import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
		    import { FontLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/FontLoader.js';
		    import { TextGeometry } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/TextGeometry.js';
		    
		    const start_color = [255, 5, 5];
		    const end_color = [0, 50, 255];
		    
		    const scene = new THREE.Scene();
		    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		    const renderer = new THREE.WebGLRenderer( { antialias: true } );
		    const geometry = new THREE.BoxGeometry();
		    
		    let cubes = JSON.parse(localStorage.getItem("cubes"));
		    let cube = null;
		    for (let i = 0; i < cubes.length; i++) {
		    	if(cubes[i].id == localStorage.getItem("current_cube")) {
		    		cube = cubes[i];
		    	}
		    }
		    document.getElementById("title").innerHTML = cube.title;
		    
		    const controls = new OrbitControls( camera, renderer.domElement );
		    const gltfLoader = new GLTFLoader();
		    
		    const color = 0xFFFFFF;
		    const intensity = 1;
		    const light = new THREE.DirectionalLight(color, intensity);
		    light.position.set(-1, 2, 4);
		    scene.add(light);	
		    scene.add( new THREE.AmbientLight( 0xffffff, 0.4 ) );
			
		    let objects = [];
		    let secs = cube.sections;
		    for (let pos = 0; pos < secs.length; pos++) {
		    	const cube_color = getColor(secs[pos]);
		    	const material = new THREE.MeshPhongMaterial( cube_color );
		    	const cube = new THREE.Mesh( geometry, material );
		    	let x = 1;
		    	let y = 1;
		    	let z = 1;
		    	if (pos % 3 == 0) {
					x = -1;
				} else if (pos % 3 == 1) {
					x = 0;
				}
				if (Math.floor(pos / 3) % 3 == 0) {
					y = -1;
				} else if (Math.floor(pos / 3) % 3 == 1) {
					y = 0;
				}
				if (Math.floor(pos / 9) == 0) {
					z = -1;
				} else if (Math.floor(pos / 9) == 1) {
					z = 0;
				}
				const gap = 1.26;
				cube.position.set( x * gap, y * gap, z * gap );
				cube.material.transparent = true;
		    	cube.material.opacity = 0.85; 
		    	if(!secs[pos].active) {
		    		cube.material.opacity = 0.35; 
		    	}
		    	cube.userData = {
                	id: secs[pos].id,
                	title: secs[pos].title,
                	intro: secs[pos].intro,
                	active: secs[pos].active,
                	strength: getStrength(secs[pos])
            	};
            	scene.add( cube );
            	objects.push(cube);
		    }
		    
		    camera.position.set(4.5,3.8,4.5);
		    camera.lookAt(new THREE.Vector3(0,0,0)); 
		    let raycaster = new THREE.Raycaster();
		    let mouse = new THREE.Vector2();
		    renderer.setPixelRatio(window.devicePixelRatio);
		    
		    renderer.setSize( window.innerWidth, window.innerHeight );
		    document.body.appendChild( renderer.domElement );
		    
		    document.addEventListener( 'mousemove', onDocumentMouseMove );
			window.addEventListener( 'resize', onWindowResize );
		    
		    document.addEventListener( 'dblclick', onDocumentDoubleClicked, false );
		    document.addEventListener("mousedown", onMouseDown);
		    document.getElementById("info_button").addEventListener("mouseup", toggleInfo);
		    
		    
		    function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}
			
			function onDocumentDoubleClicked(event) {
    			event.preventDefault();
    			raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
    			if (intersects.length > 0) {
        			localStorage.setItem('current_section', intersects[0].object.userData.id);
        			window.location.href = "section.html";
    			}
			}
			
			function onMouseDown(event) {
    			event.preventDefault();
    			raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
				for (let i = 0; i < objects.length; i++) {
					let opacity;
					if(objects[i].userData.active) {
						opacity = 0.85;
					} else {
						opacity = 0.35;
					}
    				const material = new THREE.MeshPhongMaterial( { color: "#ff0000" } );
    				material.color = objects[i].material.color;
    				material.transparent = true;
    				material.opacity = opacity; 
    				objects[i].material = material;
    			}
    			if (intersects.length > 0) {
        			document.getElementById("section_title").innerHTML = intersects[0].object.userData.title;
        			document.getElementById("section_intro").innerHTML = intersects[0].object.userData.intro;
        			intersects[0].object.material.opacity = 1; 
        			if(intersects[0].object.userData.active) {
        				intersects[0].object.material.emissive = intersects[0].object.material.color; 
        				document.getElementById("section_title").innerHTML += " (" + intersects[0].object.userData.strength + "&nbsp%)";
        			} else {
        				document.getElementById("section_title").innerHTML += " (Inaktiv)";
        				intersects[0].object.material.opacity = 0.55; 
        			};
    			} else {
    				document.getElementById("section_title").innerHTML = "";
        			document.getElementById("section_intro").innerHTML = "";
    			}
			}
			
			function toggleInfo(event) {
    			event.preventDefault();
    			let axis_info = document.getElementById("axis_info");
				if (axis_info.style.display === "none" || axis_info.style.display === "") {
					axis_info.style.display = "block";
					document.getElementById("section_title").innerHTML = "Klicka på ett område för mer information";
    				document.getElementById("section_intro").innerHTML = "Dubbelklicka på området för att öppna det";
				} else {
					axis_info.style.display = "none";
					document.getElementById("section_title").innerHTML = '';
    				document.getElementById("section_intro").innerHTML = '';
				}
			}
			
			function getColor(section) {
				if(!section.active) {
					return {color: "#222"}
				}
				let strength = getStrength(section);
				let r, g;
				let b = "00";
				if(strength <= 50) {
					r = "ff";
					g = (255 * strength) / 50;
					g = Math.round(g).toString(16);
					if(g.length == 1) {
						g = "0" + g;
					}
				} else {
					g = "ff";
					r = (255 * (100 - strength)) / 50;
					r = Math.round(r).toString(16);
					b = (50 * (strength - 50)) / 50;
					b = Math.round(b).toString(16);
					if(r.length == 1) {
						r = "0" + r;
					}
					if(b.length == 1) {
						b = "0" + b;
					}
				}
				
				let rr = Math.round(start_color[0] + ((end_color[0] - start_color[0]) / 100) * strength).toString(16);
				if(rr.length == 1) {
					rr = "0" + rr;
				}
				let gg = Math.round(start_color[1] + ((end_color[1] - start_color[1]) / 100) * strength).toString(16);
				if(gg.length == 1) {
					gg = "0" + gg;
				}
				let bb = Math.round(start_color[2] + ((end_color[2] - start_color[2]) / 100) * strength).toString(16);
				if(bb.length == 1) {
					bb = "0" + bb;
				}
				
				let colorString = "#" + r + g + b;
				colorString = "#" + rr + gg + bb;
				return {color: colorString};
			}

		    function animate() {
		        requestAnimationFrame( animate );
		        renderer.render( scene, camera );
		    }
		    animate();

		</script>
	</body>
</html>
